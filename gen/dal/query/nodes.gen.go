// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"go_web_example/gen/dal/model"
)

func newNode(db *gorm.DB) node {
	_node := node{}

	_node.nodeDo.UseDB(db)
	_node.nodeDo.UseModel(&model.Node{})

	tableName := _node.nodeDo.TableName()
	_node.ALL = field.NewField(tableName, "*")
	_node.Id = field.NewString(tableName, "id")
	_node.Name = field.NewString(tableName, "name")
	_node.Os = field.NewString(tableName, "os")
	_node.Status = field.NewInt(tableName, "status")
	_node.OnlineStatus = field.NewInt(tableName, "online_status")
	_node.AtsStatus = field.NewInt(tableName, "ats_status")
	_node.Version = field.NewString(tableName, "version")
	_node.NewVersion = field.NewString(tableName, "new_version")
	_node.MaxUpload = field.NewInt(tableName, "max_upload")
	_node.MaxDownLoad = field.NewInt(tableName, "max_download")
	_node.MemoryUsed = field.NewInt(tableName, "memory_used")
	_node.CpuUsed = field.NewInt(tableName, "cpu_used")
	_node.DiskUsed = field.NewInt(tableName, "disk_used")
	_node.CnameAddr = field.NewString(tableName, "cname_addr")
	_node.IpV6 = field.NewString(tableName, "ipv6")
	_node.SynTiming = field.NewInt(tableName, "syn_timing")
	_node.SyncConfAt = field.NewInt64(tableName, "sync_conf_at")
	_node.Pid = field.NewInt(tableName, "pid")
	_node.CacheType = field.NewInt(tableName, "cache_type")
	_node.MemCacheProportion = field.NewInt(tableName, "mem_cache_proportion")
	_node.Path = field.NewString(tableName, "path")
	_node.PartitionPath = field.NewString(tableName, "partition_path")
	_node.DiskCacheProportion = field.NewInt(tableName, "disk_cache_proportion")
	_node.UseRegionConfig = field.NewInt(tableName, "use_region_config")
	_node.RegionConfigTerm = field.NewString(tableName, "region_config_term")
	_node.RegionConfigBindId = field.NewString(tableName, "region_config_bind_id")
	_node.LastCleanCacheAt = field.NewInt(tableName, "last_clean_cache_at")
	_node.CreatedAt = field.NewInt64(tableName, "created_at")
	_node.UpdatedAt = field.NewInt64(tableName, "updated_at")

	_node.fillFieldMap()

	return _node
}

type node struct {
	nodeDo nodeDo

	ALL                 field.Field
	Id                  field.String
	Name                field.String
	Os                  field.String
	Status              field.Int
	OnlineStatus        field.Int
	AtsStatus           field.Int
	Version             field.String
	NewVersion          field.String
	MaxUpload           field.Int
	MaxDownLoad         field.Int
	MemoryUsed          field.Int
	CpuUsed             field.Int
	DiskUsed            field.Int
	CnameAddr           field.String
	IpV6                field.String
	SynTiming           field.Int
	SyncConfAt          field.Int64
	Pid                 field.Int
	CacheType           field.Int
	MemCacheProportion  field.Int
	Path                field.String
	PartitionPath       field.String
	DiskCacheProportion field.Int
	UseRegionConfig     field.Int
	RegionConfigTerm    field.String
	RegionConfigBindId  field.String
	LastCleanCacheAt    field.Int
	CreatedAt           field.Int64
	UpdatedAt           field.Int64

	fieldMap map[string]field.Expr
}

func (n node) Table(newTableName string) *node {
	n.nodeDo.UseTable(newTableName)
	return n.updateTableName(newTableName)
}

func (n node) As(alias string) *node {
	n.nodeDo.DO = *(n.nodeDo.As(alias).(*gen.DO))
	return n.updateTableName(alias)
}

func (n *node) updateTableName(table string) *node {
	n.ALL = field.NewField(table, "*")
	n.Id = field.NewString(table, "id")
	n.Name = field.NewString(table, "name")
	n.Os = field.NewString(table, "os")
	n.Status = field.NewInt(table, "status")
	n.OnlineStatus = field.NewInt(table, "online_status")
	n.AtsStatus = field.NewInt(table, "ats_status")
	n.Version = field.NewString(table, "version")
	n.NewVersion = field.NewString(table, "new_version")
	n.MaxUpload = field.NewInt(table, "max_upload")
	n.MaxDownLoad = field.NewInt(table, "max_download")
	n.MemoryUsed = field.NewInt(table, "memory_used")
	n.CpuUsed = field.NewInt(table, "cpu_used")
	n.DiskUsed = field.NewInt(table, "disk_used")
	n.CnameAddr = field.NewString(table, "cname_addr")
	n.IpV6 = field.NewString(table, "ipv6")
	n.SynTiming = field.NewInt(table, "syn_timing")
	n.SyncConfAt = field.NewInt64(table, "sync_conf_at")
	n.Pid = field.NewInt(table, "pid")
	n.CacheType = field.NewInt(table, "cache_type")
	n.MemCacheProportion = field.NewInt(table, "mem_cache_proportion")
	n.Path = field.NewString(table, "path")
	n.PartitionPath = field.NewString(table, "partition_path")
	n.DiskCacheProportion = field.NewInt(table, "disk_cache_proportion")
	n.UseRegionConfig = field.NewInt(table, "use_region_config")
	n.RegionConfigTerm = field.NewString(table, "region_config_term")
	n.RegionConfigBindId = field.NewString(table, "region_config_bind_id")
	n.LastCleanCacheAt = field.NewInt(table, "last_clean_cache_at")
	n.CreatedAt = field.NewInt64(table, "created_at")
	n.UpdatedAt = field.NewInt64(table, "updated_at")

	n.fillFieldMap()

	return n
}

func (n *node) WithContext(ctx context.Context) *nodeDo { return n.nodeDo.WithContext(ctx) }

func (n node) TableName() string { return n.nodeDo.TableName() }

func (n node) Alias() string { return n.nodeDo.Alias() }

func (n *node) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := n.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (n *node) fillFieldMap() {
	n.fieldMap = make(map[string]field.Expr, 29)
	n.fieldMap["id"] = n.Id
	n.fieldMap["name"] = n.Name
	n.fieldMap["os"] = n.Os
	n.fieldMap["status"] = n.Status
	n.fieldMap["online_status"] = n.OnlineStatus
	n.fieldMap["ats_status"] = n.AtsStatus
	n.fieldMap["version"] = n.Version
	n.fieldMap["new_version"] = n.NewVersion
	n.fieldMap["max_upload"] = n.MaxUpload
	n.fieldMap["max_download"] = n.MaxDownLoad
	n.fieldMap["memory_used"] = n.MemoryUsed
	n.fieldMap["cpu_used"] = n.CpuUsed
	n.fieldMap["disk_used"] = n.DiskUsed
	n.fieldMap["cname_addr"] = n.CnameAddr
	n.fieldMap["ipv6"] = n.IpV6
	n.fieldMap["syn_timing"] = n.SynTiming
	n.fieldMap["sync_conf_at"] = n.SyncConfAt
	n.fieldMap["pid"] = n.Pid
	n.fieldMap["cache_type"] = n.CacheType
	n.fieldMap["mem_cache_proportion"] = n.MemCacheProportion
	n.fieldMap["path"] = n.Path
	n.fieldMap["partition_path"] = n.PartitionPath
	n.fieldMap["disk_cache_proportion"] = n.DiskCacheProportion
	n.fieldMap["use_region_config"] = n.UseRegionConfig
	n.fieldMap["region_config_term"] = n.RegionConfigTerm
	n.fieldMap["region_config_bind_id"] = n.RegionConfigBindId
	n.fieldMap["last_clean_cache_at"] = n.LastCleanCacheAt
	n.fieldMap["created_at"] = n.CreatedAt
	n.fieldMap["updated_at"] = n.UpdatedAt
}

func (n node) clone(db *gorm.DB) node {
	n.nodeDo.ReplaceDB(db)
	return n
}

type nodeDo struct{ gen.DO }

func (n nodeDo) Debug() *nodeDo {
	return n.withDO(n.DO.Debug())
}

func (n nodeDo) WithContext(ctx context.Context) *nodeDo {
	return n.withDO(n.DO.WithContext(ctx))
}

func (n nodeDo) Clauses(conds ...clause.Expression) *nodeDo {
	return n.withDO(n.DO.Clauses(conds...))
}

func (n nodeDo) Returning(value interface{}, columns ...string) *nodeDo {
	return n.withDO(n.DO.Returning(value, columns...))
}

func (n nodeDo) Not(conds ...gen.Condition) *nodeDo {
	return n.withDO(n.DO.Not(conds...))
}

func (n nodeDo) Or(conds ...gen.Condition) *nodeDo {
	return n.withDO(n.DO.Or(conds...))
}

func (n nodeDo) Select(conds ...field.Expr) *nodeDo {
	return n.withDO(n.DO.Select(conds...))
}

func (n nodeDo) Where(conds ...gen.Condition) *nodeDo {
	return n.withDO(n.DO.Where(conds...))
}

func (n nodeDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) *nodeDo {
	return n.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (n nodeDo) Order(conds ...field.Expr) *nodeDo {
	return n.withDO(n.DO.Order(conds...))
}

func (n nodeDo) Distinct(cols ...field.Expr) *nodeDo {
	return n.withDO(n.DO.Distinct(cols...))
}

func (n nodeDo) Omit(cols ...field.Expr) *nodeDo {
	return n.withDO(n.DO.Omit(cols...))
}

func (n nodeDo) Join(table schema.Tabler, on ...field.Expr) *nodeDo {
	return n.withDO(n.DO.Join(table, on...))
}

func (n nodeDo) LeftJoin(table schema.Tabler, on ...field.Expr) *nodeDo {
	return n.withDO(n.DO.LeftJoin(table, on...))
}

func (n nodeDo) RightJoin(table schema.Tabler, on ...field.Expr) *nodeDo {
	return n.withDO(n.DO.RightJoin(table, on...))
}

func (n nodeDo) Group(cols ...field.Expr) *nodeDo {
	return n.withDO(n.DO.Group(cols...))
}

func (n nodeDo) Having(conds ...gen.Condition) *nodeDo {
	return n.withDO(n.DO.Having(conds...))
}

func (n nodeDo) Limit(limit int) *nodeDo {
	return n.withDO(n.DO.Limit(limit))
}

func (n nodeDo) Offset(offset int) *nodeDo {
	return n.withDO(n.DO.Offset(offset))
}

func (n nodeDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *nodeDo {
	return n.withDO(n.DO.Scopes(funcs...))
}

func (n nodeDo) Unscoped() *nodeDo {
	return n.withDO(n.DO.Unscoped())
}

func (n nodeDo) Create(values ...*model.Node) error {
	if len(values) == 0 {
		return nil
	}
	return n.DO.Create(values)
}

func (n nodeDo) CreateInBatches(values []*model.Node, batchSize int) error {
	return n.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (n nodeDo) Save(values ...*model.Node) error {
	if len(values) == 0 {
		return nil
	}
	return n.DO.Save(values)
}

func (n nodeDo) First() (*model.Node, error) {
	if result, err := n.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Node), nil
	}
}

func (n nodeDo) Take() (*model.Node, error) {
	if result, err := n.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Node), nil
	}
}

func (n nodeDo) Last() (*model.Node, error) {
	if result, err := n.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Node), nil
	}
}

func (n nodeDo) Find() ([]*model.Node, error) {
	result, err := n.DO.Find()
	return result.([]*model.Node), err
}

func (n nodeDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Node, err error) {
	buf := make([]*model.Node, 0, batchSize)
	err = n.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (n nodeDo) FindInBatches(result *[]*model.Node, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return n.DO.FindInBatches(result, batchSize, fc)
}

func (n nodeDo) Attrs(attrs ...field.AssignExpr) *nodeDo {
	return n.withDO(n.DO.Attrs(attrs...))
}

func (n nodeDo) Assign(attrs ...field.AssignExpr) *nodeDo {
	return n.withDO(n.DO.Assign(attrs...))
}

func (n nodeDo) Joins(fields ...field.RelationField) *nodeDo {
	for _, _f := range fields {
		n = *n.withDO(n.DO.Joins(_f))
	}
	return &n
}

func (n nodeDo) Preload(fields ...field.RelationField) *nodeDo {
	for _, _f := range fields {
		n = *n.withDO(n.DO.Preload(_f))
	}
	return &n
}

func (n nodeDo) FirstOrInit() (*model.Node, error) {
	if result, err := n.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Node), nil
	}
}

func (n nodeDo) FirstOrCreate() (*model.Node, error) {
	if result, err := n.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Node), nil
	}
}

func (n nodeDo) FindByPage(offset int, limit int) (result []*model.Node, count int64, err error) {
	result, err = n.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = n.Offset(-1).Limit(-1).Count()
	return
}

func (n nodeDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = n.Count()
	if err != nil {
		return
	}

	err = n.Offset(offset).Limit(limit).Scan(result)
	return
}

func (n *nodeDo) withDO(do gen.Dao) *nodeDo {
	n.DO = *do.(*gen.DO)
	return n
}
